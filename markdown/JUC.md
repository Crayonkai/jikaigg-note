# JUC

> JUC就是java.util.concurrent工具包的简称，这是一个处理线程的工具包，JDK1.5开始出现的

## 基本概念

### 进程和线程

#### 进程：

进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

#### 线程：

线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

###二者的区别

1. 进程是资源分配的最小单位，线程是程序执行的最小单位
2. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4. 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

### 线程的六种状态

```JAVA
NEW：新建
RUNNABLE：就绪
BLOCKED：阻塞
WAITING：等待
TIMED_WAITING：计时等待
TERMINATED：终结
```

### wait和sleep

wait方法是Object中的方法，任何对象实力都能调用

sleep不会释放锁，他也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁（即代码中用synchronized）

### 并发和并行

#### 并发

把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。

#### 并行

把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。

### 管程

管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但是具有与信号量及PV操作不同的属性。就是锁，java中是Monitor.

### 用户线程和守护线程

> setDaemon(true) // 设置线程为守护线程。

#### 用户线程

自定义线程，平时程序用到的线程。

主线程结束，用户线程还在运行，JVM存活

#### 守护线程

一种特殊的线程，比如垃圾回收。

没有用户线程，剩的都是守护线程，JVM会结束

## Lock接口

### synchronized关键字

synchronized是java中的一个关键字，在中文中为同步，也被称之为’同步锁’,以此来达到多线程并发访问时候的并发安全问题，可以用来修饰代码块、非静态方法。静态方法等；

* 修饰代码块时:给当前指定的对象加锁
* 修饰非静态方法时:作用于当前实例加锁
* 修饰静态方法时:作用于当前类对象加锁

**synchronized在java内存模型中的主要作用**

* 原子性:通过monitorenter和monitorexit指令,保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到
* 可见性:保证共享变量的修改能够及时可见,对一个变量的unlock操作之前，必须把此变量同步回主内存中(store和write操作)
* 有序性:一个变量在同一时刻只允许一条线程对其执行lock操作，这条规则决定了持有同一个锁的两个同步块只能串行执行

### 线程间通信





## 锁

### 公平锁和非公平锁





### 可重入锁（递归锁）

synchronized：隐式

Lock：显式



### 死锁









## 创建线程的四种办法

1. 继承Thread类
   * 无返回值
2. 实现Runnable接口
   * 无返回值
   * 重写run方法
   * 无异常
3. 实现Callable接口
   * 有返回值
   * 重写call方法
   * 有可能抛异常
4. 使用线程池

## ThreadLocal

>多线程中创建线程私有局部变量的一个类，里面的方法有set、get、withInitial、remove

Thread中会维护一个ThreadLocalMap，是一个Entry数组，继承了一个弱引用接口WeakReference<ThreadLocal<?>>，ThreadLocal就是这个ThreadLocalMap的一个Entry。

### ThreadLocalMap的hash冲突

ThreadLocalMap是一个数组。没有链表和红黑树的数据结构，set的时候会首先进行hash，然后看当前hash对应的数组位置上是有Entry如果有的话对比key是否一致，一直的话更新value值，不一致的话会在数组+1的位置进行插入，如果数组+1的唯一也不为空就往后+1，知道找到空的数组位置把Entry放进去。get的方法也是一样，hash完之后对比key，如果不一致去+1位get。

### 应用场景

像spring中通过ThreadLocal来保证当个数据库操作使用的是同一个连接。通过事物的传播级别，在多个事务之间做一些个巧妙的切换。

### 内存泄露的问题

内存泄漏就是说内存中有一些个无法被释放那么就无法被回收，ThreadLocal使用的是弱引用，Thread强引用了ThreadLocalMap，ThreadLocal在ThreadLocalMap中。解决的办法就是我们使用完ThreadLocal后调用一下remove方法将Entry移除，就能通过手动的方式避免内存泄漏。

























































































